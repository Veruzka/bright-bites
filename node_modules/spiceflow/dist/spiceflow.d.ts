import { ComposeSpiceflowResponse, ContentType, CreateClient, DefinitionBase, ErrorHandler, HTTPMethod, InlineHandler, InputSchema, IsAny, JoinPath, LocalHook, MaybeArray, MetadataBase, MiddlewareHandler, Reconcile, ResolvePath, RouteBase, RouteSchema, SingletonBase, UnwrapRoute } from './types.js';
import { ValidateFunction } from 'ajv';
import { ZodType } from 'zod';
export type InternalRoute = {
    method: HTTPMethod;
    path: string;
    type: ContentType;
    handler: InlineHandler<any, any, any>;
    hooks: LocalHook<any, any, any, any, any, any, any>;
    validateBody?: ValidateFunction;
    validateQuery?: ValidateFunction;
    validateParams?: ValidateFunction;
};
export declare class Spiceflow<const in out BasePath extends string = '', const in out Scoped extends boolean = true, const in out Singleton extends SingletonBase = {
    state: {};
}, const in out Definitions extends DefinitionBase = {
    type: {};
    error: {};
}, const in out Metadata extends MetadataBase = {
    schema: {};
    macro: {};
    macroFn: {};
}, const out Routes extends RouteBase = {}> {
    private id;
    private router;
    private middlewares;
    private onErrorHandlers;
    private routes;
    private defaultState;
    topLevelApp?: AnySpiceflow;
    /** @internal */
    prefix?: string;
    /** @internal */
    childrenApps: AnySpiceflow[];
    /** @internal */
    getAllRoutes(): {
        path: string;
        method: HTTPMethod;
        type: ContentType;
        handler: InlineHandler<any, any, any>;
        hooks: LocalHook<any, any, any, any, any, any, any>;
        validateBody?: ValidateFunction;
        validateQuery?: ValidateFunction;
        validateParams?: ValidateFunction;
    }[];
    private add;
    private match;
    state<const Name extends string | number | symbol, Value>(name: Name, value?: Value): Spiceflow<BasePath, Scoped, {
        state: Reconcile<Singleton['state'], {
            [name in Name]: Value;
        }>;
    }, Definitions, Metadata, Routes>;
    /**
     * Create a new Router
     * @param options {@link RouterOptions} {@link Platform}
     */
    constructor(options?: {
        name?: string;
        scoped?: Scoped;
        basePath?: BasePath;
    });
    _routes: Routes;
    _types: {
        Prefix: BasePath;
        Scoped: Scoped;
        Singleton: Singleton;
        Definitions: Definitions;
        Metadata: Metadata;
    };
    post<const Path extends string, const LocalSchema extends InputSchema<keyof Definitions['type'] & string>, const Schema extends UnwrapRoute<LocalSchema, Definitions['type']>, const Handle extends InlineHandler<Schema, Singleton, JoinPath<BasePath, Path>>>(path: Path, handler: Handle, hook?: LocalHook<LocalSchema, Schema, Singleton, Definitions['error'], Metadata['macro'], JoinPath<BasePath, Path>>): Spiceflow<BasePath, Scoped, Singleton, Definitions, Metadata, Routes & CreateClient<JoinPath<BasePath, Path>, {
        post: {
            body: Schema['body'];
            params: undefined extends Schema['params'] ? ResolvePath<Path> : Schema['params'];
            query: Schema['query'];
            response: ComposeSpiceflowResponse<Schema['response'], Handle>;
        };
    }>>;
    get<const Path extends string, const LocalSchema extends InputSchema<keyof Definitions['type'] & string>, const Schema extends UnwrapRoute<LocalSchema, Definitions['type']>, const Macro extends Metadata['macro'], const Handle extends InlineHandler<Schema, Singleton, JoinPath<BasePath, Path>>>(path: Path, handler: Handle, hook?: LocalHook<LocalSchema, Schema, Singleton, Definitions['error'], Macro, JoinPath<BasePath, Path>>): Spiceflow<BasePath, Scoped, Singleton, Definitions, Metadata, Routes & CreateClient<JoinPath<BasePath, Path>, {
        get: {
            body: Schema['body'];
            params: undefined extends Schema['params'] ? ResolvePath<Path> : Schema['params'];
            query: Schema['query'];
            response: ComposeSpiceflowResponse<Schema['response'], Handle>;
        };
    }>>;
    put<const Path extends string, const LocalSchema extends InputSchema<keyof Definitions['type'] & string>, const Schema extends UnwrapRoute<LocalSchema, Definitions['type']>, const Handle extends InlineHandler<Schema, Singleton, JoinPath<BasePath, Path>>>(path: Path, handler: Handle, hook?: LocalHook<LocalSchema, Schema, Singleton, Definitions['error'], Metadata['macro'], JoinPath<BasePath, Path>>): Spiceflow<BasePath, Scoped, Singleton, Definitions, Metadata, Routes & CreateClient<JoinPath<BasePath, Path>, {
        put: {
            body: Schema['body'];
            params: undefined extends Schema['params'] ? ResolvePath<Path> : Schema['params'];
            query: Schema['query'];
            response: ComposeSpiceflowResponse<Schema['response'], Handle>;
        };
    }>>;
    patch<const Path extends string, const LocalSchema extends InputSchema<keyof Definitions['type'] & string>, const Schema extends UnwrapRoute<LocalSchema, Definitions['type']>, const Handle extends InlineHandler<Schema, Singleton, JoinPath<BasePath, Path>>>(path: Path, handler: Handle, hook?: LocalHook<LocalSchema, Schema, Singleton, Definitions['error'], Metadata['macro'], JoinPath<BasePath, Path>>): Spiceflow<BasePath, Scoped, Singleton, Definitions, Metadata, Routes & CreateClient<JoinPath<BasePath, Path>, {
        patch: {
            body: Schema['body'];
            params: undefined extends Schema['params'] ? ResolvePath<Path> : Schema['params'];
            query: Schema['query'];
            response: ComposeSpiceflowResponse<Schema['response'], Handle>;
        };
    }>>;
    delete<const Path extends string, const LocalSchema extends InputSchema<keyof Definitions['type'] & string>, const Schema extends UnwrapRoute<LocalSchema, Definitions['type']>, const Handle extends InlineHandler<Schema, Singleton, JoinPath<BasePath, Path>>>(path: Path, handler: Handle, hook?: LocalHook<LocalSchema, Schema, Singleton, Definitions['error'], Metadata['macro'], JoinPath<BasePath, Path>>): Spiceflow<BasePath, Scoped, Singleton, Definitions, Metadata, Routes & CreateClient<JoinPath<BasePath, Path>, {
        delete: {
            body: Schema['body'];
            params: undefined extends Schema['params'] ? ResolvePath<Path> : Schema['params'];
            query: Schema['query'];
            response: ComposeSpiceflowResponse<Schema['response'], Handle>;
        };
    }>>;
    options<const Path extends string, const LocalSchema extends InputSchema<keyof Definitions['type'] & string>, const Schema extends UnwrapRoute<LocalSchema, Definitions['type']>, const Handle extends InlineHandler<Schema, Singleton, JoinPath<BasePath, Path>>>(path: Path, handler: Handle, hook?: LocalHook<LocalSchema, Schema, Singleton, Definitions['error'], Metadata['macro'], JoinPath<BasePath, Path>>): Spiceflow<BasePath, Scoped, Singleton, Definitions, Metadata, Routes & CreateClient<JoinPath<BasePath, Path>, {
        options: {
            body: Schema['body'];
            params: undefined extends Schema['params'] ? ResolvePath<Path> : Schema['params'];
            query: Schema['query'];
            response: ComposeSpiceflowResponse<Schema['response'], Handle>;
        };
    }>>;
    all<const Path extends string, const LocalSchema extends InputSchema<keyof Definitions['type'] & string>, const Schema extends UnwrapRoute<LocalSchema, Definitions['type']>, const Handle extends InlineHandler<Schema, Singleton, JoinPath<BasePath, Path>>>(path: Path, handler: Handle, hook?: LocalHook<LocalSchema, Schema, Singleton, Definitions['error'], Metadata['macro'], JoinPath<BasePath, Path>>): Spiceflow<BasePath, Scoped, Singleton, Definitions, Metadata, Routes & CreateClient<JoinPath<BasePath, Path>, {
        [method in string]: {
            body: Schema['body'];
            params: undefined extends Schema['params'] ? ResolvePath<Path> : Schema['params'];
            query: Schema['query'];
            response: ComposeSpiceflowResponse<Schema['response'], Handle>;
        };
    }>>;
    head<const Path extends string, const LocalSchema extends InputSchema<keyof Definitions['type'] & string>, const Schema extends UnwrapRoute<LocalSchema, Definitions['type']>, const Handle extends InlineHandler<Schema, Singleton, JoinPath<BasePath, Path>>>(path: Path, handler: Handle, hook?: LocalHook<LocalSchema, Schema, Singleton, Definitions['error'], Metadata['macro'], JoinPath<BasePath, Path>>): Spiceflow<BasePath, Scoped, Singleton, Definitions, Metadata, Routes & CreateClient<JoinPath<BasePath, Path>, {
        head: {
            body: Schema['body'];
            params: undefined extends Schema['params'] ? ResolvePath<Path> : Schema['params'];
            query: Schema['query'];
            response: ComposeSpiceflowResponse<Schema['response'], Handle>;
        };
    }>>;
    private scoped?;
    use<const NewSpiceflow extends AnySpiceflow>(instance: NewSpiceflow): IsAny<NewSpiceflow> extends true ? this : Spiceflow<BasePath, Scoped, Singleton, Definitions, Metadata, BasePath extends `` ? Routes & NewSpiceflow['_routes'] : Routes & CreateClient<BasePath, NewSpiceflow['_routes']>>;
    use<const Schema extends RouteSchema>(handler: MiddlewareHandler<Schema, {
        state: Singleton['state'];
    }>): this;
    onError<const Schema extends RouteSchema>(handler: MaybeArray<ErrorHandler<Definitions['error'], Schema, Singleton>>): this;
    handle(request: Request): Promise<Response>;
    private runErrorHandlers;
    private getAppAndParents;
    private getAppsInScope;
    listen(port: number, hostname?: string): Promise<any>;
    listenNode(port: number, hostname?: string): Promise<import("http").Server<typeof import("http").IncomingMessage, typeof import("http").ServerResponse>>;
    private handleStream;
}
declare const METHODS: readonly ["ALL", "CONNECT", "DELETE", "GET", "HEAD", "OPTIONS", "PATCH", "POST", "PUT", "TRACE"];
/** HTTP method string */
export type Method = (typeof METHODS)[number];
export declare class SpiceflowRequest<T = any> extends Request {
    validateBody?: ValidateFunction;
    json(): Promise<T>;
}
export declare function bfs(tree: AnySpiceflow): AnySpiceflow[];
export declare function turnHandlerResultIntoResponse(result: any, route: InternalRoute): Promise<Response>;
export type AnySpiceflow = Spiceflow<any, any, any, any, any, any>;
export declare function isZodSchema(value: unknown): value is ZodType;
export declare function cloneDeep(x: any): any;
export {};
//# sourceMappingURL=spiceflow.d.ts.map